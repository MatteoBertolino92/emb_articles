## Short overview of Merkle Trees
Merkle trees are widely used to verify any kind of data which are transferred or archived through the use of cryptographic hashes. Briefly, "verifying" means assuring that a certain data block has not been tampered/it really comes from who claims to be the sender of it. Variants of Merkle trees are mainly used in Ethereum, Bitcoin or in any other blockchain peer-to-peer network.

Merkle tree composition:
* Leaves contains the hash of actual data (e.g., transactions in Ethereum).
* Intermediate nodes (named _inodes_) contains the cryptographic hash of its two children.
* A single root node, the top of the tree, that has the same property of an inode.

The point is being able to demonstrate that a child node is really part of a certain Merkle tree. This is computational expensive because you should compute the hash of all its ancestors, which in `O` notation is `O(L)`, where `L` is the number of leaves in the tree.

Let's translate this data structure in cryptocurrency, like Ethereum (actually, there are slight differences among each of them. This short explanation is _generic enough_ to understand the concept). We assume you already know what a block is and the meaning of each component (hash, nonce, proof-of-work, and so on). When we talk about the hash of a block, we actually talk about the hash of the block header. A block header does not contain data actually (i.e., the ethereum transactions, such as "Alice->Bob;1 eth"), but only timestamp, nonce, hash of the previous block in the blockchain and the hash of the root of the Merkle tree. Leaves of a Merkle tree stores all the transactions of a block (up to thousands). As we already told, not the complete files are stored, but only the hash (on 256 bit for Bitcoin/Eth). Why? Because storing real data is too expensive. According to [this source](https://ethereum.org/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/):
> Storing a 32-byte word typically costs 20,000 gas, around 6.60$ (01/2023).

Hashing the data is an option, but it is still too expensive. The hash of the root node of the tree is the only part that needs to be stored on the blockchain (hash algorithm in Ethereum blockchain: _Keccak-256_).

Why does this data structure protect from tampering transactions? Why can't an attacker simply change a transaction in a leaf, for instance from "Alice->Bob;1 Eth" to "Alice->Bob;9999 eth"? Because **the hash is propagated upward**. This means that the root of the tree has an hash which is generated by combining a bunch of information (nonce of a block, timestamp, etc.) plus the has of its children (inodes). The has of each inode depends, in turn, on the hash of the two children (two because it is a binary tree), until arriving to the leaves which stores the hash of the transaction.

Let's imagine to tamper a transaction:
1. the hash of the transaction changes;
2. the hash of the parent inode changes;
3. the hash of each inode changes as well;
4. the hash of the Merkle tree root changes;
5. the hash of the block changes, the proof-of-work for the block will fail.

The upward propagation of the hash guarantees the integrity of a block and it is the reason for which tampering a blockchain transaction has an almost null probability to be successful.

The distributed nature of the blockchain allows a node of a blockchain (a peer) to download the header of a block from a source, the tree (or a portion of the tree, from the transaction to the root) from another source and still verifying the integrity of the transaction.

Final note: Ethereum blockchains use a variant of Merkle trees named [Merkle Patricia trees](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/).

## Useful links
1. [Merkling in ethereum](https://blog.ethereum.org/2015/11/15/merkling-in-ethereum/)
2. [Blockchain demo](https://andersbrownworth.com/blockchain/blockchain)
3. [Solidity bootcamp](https://www.youtube.com/watch?v=M576WGiDBdQ)
